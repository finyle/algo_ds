# 1. 基本算法(44)
# 1. 位运算
# 1. a^b(移位运算：二进制补码表示下，把数字同时向左或向右移)：求a的b次方对p取模的值
# 2. 64位整数乘法: 求a乘b对p取模的值：数学推导无需遍历
# 3. 最短hamilton路径(二进制状态压缩：将一个长度为m的bool数组用一个m位二进制整数表示并存储的方法)：给定n个点的带权无向图，从起点0到终点n-1的最短hamiltom路径：不重不满的经过每个点恰好一次
# 4. 起床困难综合症：选择区间[0,m]之间的一个整数x0，经过给定的n次位运算(与，或，异或)，使结果ans最大(位运算的主要特点是在二进制表示下不进位)， 遍历操作列表，输出最大值
# 成对变换: n位偶数时n xor 1 == n + 1; n位奇数时，n xor 1 == n - 1
# lowbit 运算：非负整数n在二进制表示下 最低位的1及其后边所有的0构成的数值 lowbit(10) = 2; lowbit(x) = (x & -x), 也是树状数组的基本操作

# 2.  递推与递归
# 1. 递归实现指数型枚举：从1~n这n个整数中随机选取任意多个，输出所有可能的选择方案
# 2. 递归实现组合型枚举：从1~n这n个整数中随机选出m个，输出所有可能的选择方案
# 3. 递归实现排列型枚举：把1~n这n个整数排列称一行后随机打乱顺序，输出所有可能的次序
# 4. 费解的开关： 5*5的01矩阵中，点击任意位置，该位置的上下左右四个相邻的位置中的数字都会变化，最少多少次点击把给定的01矩阵完全变成0矩阵
# 5. strange towers of hanoi：汉诺塔问题变形：n个盘子，4座塔的汉诺塔问题
# 6. Sumdiv(分治：把一个问题划分成若干个规模更小的同类子问题，对这些问题递归求解，然后在回溯时通过它们推导出原问题的解)： 求a的b次幂的约数之和
# 7. fractal streets(分形)： 分形街道，求编号为m的房屋在n级城市中的位置
# 8. 非递归实现组合枚举(递归的机器实现)

# 3. 前缀和与差分
# 1. 激光炸弹(前缀和：对于给定的数列A，它的前缀和数列是通过递推能求出的基本信息之一)： 二维矩阵元素记录权重值，炸弹可炸毁长度为r的正方形，求最大炸毁权重
# 2. IncDec Sequence(差分：前缀和和差分是一对互逆运算)： 给定长度为n的序列，每次选择一个区间，是下标在这个区间内的数都加一，减一，至少需要多少次操作，才能使区间中的数完全相同
# 3. Tallest Cow： n头牛站成一行，两头牛能相互看到，求每头牛的最大身高为多少？

# 4. 二分: 当问题的答案具有但典型时，可以通过二分把求解转化为判定:根据复杂度理论，判定的难度小于求解)
# 1. Best cow fence：给定整数数列n，求一个平均数最大的，长度不小于l的最长子段(子段必须连续)
# 2. innovative business： n个元素，每对元素间的大小关系确定，关系不具有传递性，将n个元素拍成一行，使得每个元素都小于它右边的相邻元素

# 5. 排序(比较排序：选择；插入；冒泡/ 堆排序；归并；快排， 外排序：计数排序，基数排序，桶排序)
# 1. cinema(离散化： 把无穷大集合中的若干个元素映射为有限集合，以便于统计的方法)： m部电影，n个人看，选择任意一部，使得高兴的人最多
# 2. 货仓选址(中位数)：数轴上有n个节点，选择一点使其到所有节点的距离和最小 
# 3. 七夕祭： 交换相邻的点,使得各行中相同的数值尽量多
# 4. running median： 动态维护中位数：依次读入一个整数序列，每当已经读入的整数个数为奇数时，输出已读入的整数构成的序列的中位数
# 5. ultra-quicksort(逆序对)： 长度为n的序列a，只允许相邻元素两两交换，至少需要多少次将a从小到大排列
# 6. 奇数码问题：扩展8puzzle：n*n的网格中，给定两个奇数码的局面，判断是否能转化

# 6. 倍增： 成倍增长：进行递推时，如果状态空间很大，通常的线性递推无法满足实践与空间芜杂都的要求，递推问题的状态空间关于2的次幂具有可划分性
# 1. genius ACM：给定整数m，对于任意一个整数集合S，定义校验值如下：从集合S中取出M对数，使得每对数的差的平方之和最大，这个最大值就称为集合s的校验值，给定长度为n的数列A和一个整数T，把A分成若干段，使得每段的校验值都不超过t，最少需要分成几段？
# 2. RMQ问题(区间最值问题)： 给定长度为n的数列a，st算法能在O(N log N)时间的预处理后，以O(1)的时间复杂度在线回答 数列A在下标l~r之间的数的最大值是多少

# 7. 贪心
# 1. sunscreen： n头牛防晒，防晒剂数量数组a，最多同时满足几头牛防晒
# 2. stall reservation：n头牛吃草的起始，结束时间，求最少的畜栏数，和每头牛吃草的时间安排
# 3. radar installation： 二维数组表示建筑坐标，x轴安装监控，半径为r的圆，最少的监控所有建筑
# 4. 国王游戏： 二维数组，n个人的左右手数字，金币规则：之前所有人左手数字乘积，除以该人右手数字，使得所有人获得金币最少的排队方案
# 5. color a tree: n个节点的树染色，染色代价为t*w,t为当前第几次染色，w为节点权重值，求将树染色的最小代价

# 8. exp：(page 58)
# 1. Pilots brothers' Refrigerator: 4*4的二维01矩阵转换，求全部转换成0或1的最少操作次数，规则：特定位置转换时，同行同列同时转换： (枚举/ 位运算)
# 2. 占卜DIY: 扑克牌占卜，13堆牌，每堆4张，计算一共开了几对，最后一堆为生命牌， (模拟)
# 3. Fractal： 画出n级分形box (递归/分形)
# 4. Raid: 平面上的最近点对 (分治/平面最近点对)
# 5. 防线： (二分)
# 6. Corral the Cows： 二分/离散化/前缀和
# 7. 糖果传递： 有n个小朋友坐成一圈，每人有ai个糖果。每人只能给左右两人传递糖果。每人每次传递一个糖果代价为1。求所有人获得均等糖果的最小代价  (排序/中位数/环形均分纸牌)
# 8. Soldiers： n个士兵随机分布在全国，可以上下左右移动，最小化移动次数完成部署,给定士兵起始和目的地 (排序/中位数/货仓选址问题)
# 9. Number Base Conversion： 高精度运算/进制转换
# 10. Cow Acrobats： 贪心/邻项交换
# 11. To the Max: 最大子矩阵和 (贪心)
# 12. Task: m个任务待完成，第i个任务需要xi时间，收益(500xi + 2ji)(贪心)

# #################################################################
# 基本数据结构：(38)
# 1. 栈: 实现一个栈，支持 push, pop, getMin 三个操作，时间复杂度为O(1)
# 1. editor: 维护一个整数序列的编辑器，5种操作：光标插入，删除，左右移动，查询最大前缀和
# 2. 火车进出栈问题(进出栈序列问题: 搜索(递归), 递推， dp， 数学：求卡特兰数)：给定n个整数和一个无限大的栈，每个数都进栈出栈一次，进栈顺序为1，2，...,N,可能的出栈顺序有多少种？
#  expression: (表达式计算：中缀表达式：最常见的表达式， 前缀：波兰式 op A B, 后缀表达式 A B op)
# 3. largest rectangle in a histogram(单调栈:及时排除不可能的选项，保持策略集合的高度有效性和秩序性): 直方图中的最大矩形

# 2. 队列
# 1. team queue： n 个小组排队，每个小组中若干人。给定入队和出队指令，输出出队顺序
# 2. 蚯蚓: 
# 3. 双端队列: 对n个数进行排序，只能使用若干个双端队列，必须依次处理这些书，对每个数只能：创建一个新双队列，并将Ai
# 4. 最大子序和(单调队列)： 给定长度为n的整数序列，找出长度不超过m的连续子序列，使得子序列中所有数的和最大

# 3. 链表与邻接表(数组支持随机访问但不能在任意位置插入或删除元素，链表支持顺序访问但可在任意位置传入或删除)
# 1.邻值查找：带有索引数组的多个数据链表构成的结构集合(平衡树， 链表)
# 2. Running Median

# 4. Hash
# 1. snowflake snow snowflakes： n片雪花中是否存在两片形状完全相同的雪花：顺时针或逆时针得到相同的六元组
# 2. 兔子与兔子(字符串哈希:把一个任意长度的字符串映射成一个非负整数，并且其冲突概率几乎为零)： 每次选择两个区间，判断区间内字符是否完全相同
# 3. palindrome： 给定字符串，返回它的最长回文子串
# 4. 后缀数组：通常使用倍增或DC3算法事项； 使用快排 快排，hash，二分实现一个简单的O(nlog^2n);

# 5. 字符串
# 1. KMP： 模式匹配：在线性时间内判定字符串A[1~N]是否为字符串B[1~N]的子串，并求出字符串A在字符串B中各次出现的位置
# 2. period： 如果一个字符从S是由一个字符串T 重复K西形成的，则称T是S的循环元，使K最大的字符串T称为S的最小循环元，求出最小循环元长度和最大循环次数
# 3. 最小表示法: 给定字符串s，如果不断的把它的最后一个字符放到开头，最终会得到n个字符串，称这n个字符串是循环同构的，这些字符串中字典序最小的一个称为字符串s的最小表示

# 6. Trie： 用于实现字符串快速检索的多叉树结构，每个节点都拥有若干个字符串指针，若在插入或检索字符串时扫描到一个字符c，就沿着当前节点的c字符串指针，走向该指针指向的节点
# 1. the XOR largest pair： 给定n个整数，选出两个进行xor计算，返回最大的计算结果
# 2. the XOR largest path
# 3. 前缀统计： 给定n个字符串S1 S2 SN, 进行m次询问，每次询问给定一个字符串T， 求S1~Sn中有多少个字符串是T的前缀。输入字符串的总长度不超过10^6

# 7. 二叉堆： 满足堆性质的完全二叉树：树上的每个节点都带有一个权值，若树中任意一个节点的权值都小于等于其父节点的权值，则为大根堆性质
# 1. sequence： 给定长度为n的序列，从每个序列中任取一个数求和，可以构成 N^M个和，求其中最小的n个和
# 2. supermarket： 给定n个商品，每个商品由利润pi和过期时间di，每天只能卖一个商品，过期商品不能再卖，求如何安排每天卖的商品，可以使收益最大
# 4. 数据备份： 选择k对办公楼，使得每对办公楼之间的距离之和(总距离)尽可能小
# 3. 合并果子(Huffman树：构造包含n个叶子节点的k叉树，其中第i个叶子节点带有权值Wi，最小化sum(wi*li),li表示第i个叶子节点到根节点的距离： 构造一个包含n个叶子节点的k叉树，其中第i个叶子节点带有权值wi，最小化sum(wi * li) li表示第i个叶子节点到根节点的距离：k叉huffman树(哈夫曼树)
# 5. 荷马史诗： 哈夫曼树

# 8. exp
# 1. 括号画家(栈):
# 2. 表达式计算(栈/中缀表达式计算)_std_中缀转后缀& 递归法求值
# 3. cityGame(单调栈)： 二维01矩阵，只包含0或1的最大子矩阵面积
# 4. 双栈排序(栈)
# 5. 滑动窗口(单调队列)
# 6. 内存分配(链表/二叉堆)：给定任务描述(起始，终止，优先级), 模拟任务执行
# 7. Matrix（字符串hash)：01矩阵的子矩阵包含
# 8. subway tree system(hash/树的最小表示)
# 9. necklace(字符串/最小表示法)
# 10. milking grid(字符串/KMP模式匹配)
# 11. 匹配统计(字符串/KMP模式匹配)： 给定两个字符串a，b整数x，满足a从x位置开始的后缀子串与b匹配
# 12. phone list(Trie)： 给定一列电话号码，判断在没有emergency前缀时，它们是否相同
# 13. black_box： 二叉堆
# 14. 生日礼物(二叉堆/链表/贪心)： 给定一个序列，返回不超过m个连续的部分的最大和

# #####################################################################
# 搜索 (32)
# 1. 树与图遍历:
# 树与图的深度优先遍历，树的DFS序，深度和重心； 树与图的广度优先遍历，拓扑排序
# 1. 可达性统计： 给定n个点m条边的有向无环图，统计从每个点出发能够到达的点数

# 2.dfs
# 2. 小猫爬山： 送n只猫下山，缆车最大承重w，每辆缆车费用为1，最少费用
# 1. sudoku： 9*9 的数独，每行，每列， 每个3*3的九宫格内数组1-9恰好只出现一次

# 3. 剪枝：(优化搜索顺序，排除等效冗余； 可行性剪枝，最优性剪枝，记忆化)
# 1. sticks： 一组等长木棍，随机砍断每节长度不超过50，复原时初始的最小长度，正在拼第stick根原始木棍，第stick根木棍的当前长度为cab，拼接到第stick根木棍根木棍中的上一根为last
# 2. sudoku：
# 3. 生日蛋糕： 制作体积为n的层生日蛋糕，每层都是个圆柱体，蛋糕的设计：r，h，使得蛋糕的表面积最小

# 4. 迭代加深： 限制搜索深度，在当前深度限制下，找不到答案，就增加深度
# 1. addition chains(迭代加深)： 给定整数n，找出符合条件的长度m最小的 ”加成序列“ 如果有多个满足要求的答案，找出任意一个可行解
# 2. 送礼物（双向搜索：从初态和中泰出发个搜索一半状态，产生两颗深度减半的搜索树，在中间教会，组合成最终的答案)： 从给定的n个数中选择几个，使得它们的和最接近w(子集和问题)

# 5. bfs
# 1. Bloxorz： 长方体在二维平面上滚动，待限制条件，判断最短滚动次数
# 3. 矩阵距离：给定n行m列的01矩阵A， A[i][j] 与 A[k][l]之间的曼哈顿距离定义为：dist(A[i][j], A[k][l])=|i-k|+|j-l|
# 2. Pushing Boxes： 推箱子游戏模拟，求移动方案，使箱子的移动次数最少，人的移动次数最少。方案：大写字母表示箱子移动，小写字母表示人的移动

# 6. 广搜变形
# 2. 电路维修(双端队列：边权均为1的图上执行bfs，求每个点相对于起点的最短距离)：二维矩阵对角斜边，旋转最少次数，使得从左上到右下构成通路
# 1. full tank(优先队列：二叉堆，每次从队列中取出当前代价最小的状态进行扩展)：n个城市，m条道路构成一张无向图，每个城市里有一个加油站，prices[],计算容量为c的车，从起点到终点至少花费多少油费？
# 3. nightmare II(双向bfs: 从初态和终态分别开始，两边轮流进行，每次各扩展一整层)：给定n*m的地图，男，女，两个鬼，道路，墙，每秒男移动3个位置，女移动一个，鬼向四周扩散2个，无视墙，再不进入鬼占领区的前体现，男女回合的最短时间

# 7. Astar： 带有估价函数的优先队列BFS
# 1. eight puzzle： 8数码问题，Astar，最少移动步数
# 2. 第k短路： 给定n个点，m条边的有向图，求从起点s到终点t第k条最短路径长度，优先队列

# 8. IDA*: 若当前深度+未来估计步数>深度限制，则立即从当前分治回溯
# 1. booksort： 给定n本书，书任意排列，每次操作抽取其中连续一段，再把这段插入到其他某个位置，把书排序，最少需要多少次操作，若大于5，输出5 or more
# 3. the rotation game： # 字棋盘，1，2，3数字各8个，给定8种操作分别为A~H，判断始终状态的最少变换次数
# 2. square destroyer： 在有火柴棒拼成的n*n的网格图种去掉一些边，构成的图形，至少再去掉多少根火柴棒使得图中不含有正方形

# 9. exp
# 1. 靶型数独(dfs/剪枝/位运算优化： 数独游戏，九宫格中每个赋予不同权值，越靠近中心分值越高，求数独最大分数
# 2. 虫食算:（dfs/ 剪枝)判断字符矩阵中空缺位置的数字
# 3. 7行5列，消消乐(dfs)
# 4. 公交车(dfs/ 迭代加深)
# 5. 导弹防御系统：(dfs/迭代加深)
# 6. 武士风度的牛：二维矩阵移动的最短距离，(bfs)
# 7. 乳草的入侵：二维数组，病毒完全扩散的最短天数(bfs)
# 8. 字串变换：给定两个字符串，返回最少的变换次数(bfs/双向广搜)
# 9. 天气预报：二维数组：递增路径(bfs)
# 10. Bloxorz：长方体二维平面滚动的最少次数(bfs/数学)
# 11. 快速幂(A*)
# 12. 二维矩阵染色，最少步数(IDA*)
# 13. 棋盘走法：(IDA*)
# ######################################################################
# 数学(46)
# 1. 数论：
# 质数
# 1. prime distance: 给定两个整数l r， 求闭区间[l,r]中相邻两个质数的差最大是多少？输出这两个质数
# 2. 阶乘分解：给定整数n，试把阶乘n！分解质因数，按照算术基本定理的形式输出结果中的pi和ci
# 约数
# 1. 反素数： 某个正整数满足：对于任意的0 < i < x, 都有g(x) > g(i), 那么称x为反质数，例如1，2，4，6都是反质数，求不超过n的最大反质数：约数个数最多的数中最小的一个
# 2. 余数之和: 给定正整数n和k， 计算 (k mod 1) + (k mod 2) + ... + (k mod n) 的值，
# 3. Hankson的趣味题(最大公约数) n个询问，在每个讯问中给定4个自然数abcd，然后求有多少个x满足gcd(a,x) = c；并且lcm(b,x) = d
# 4. Visible Lattice Points(平面直角坐标系以(0,0)为左下角，(n,n)为右上角的矩形中，出原点外每个点都查了一颗钉子，求所有能看到的钉子以及视线)

# 同余: 若整数a和整数b除以正整数m的余数相等，称a与b模m同余
# 1. the luckiest number： 给定正整数l，至少多少个8连在一起组成的正整数是l的倍数？
# 2. sumdiv(扩展欧几里得算法)： 求A^B的所有约数之和 mod 9901
# 3. strange way to express integers： 给定2n个正整数a1...an,和m1...mn,求一个最小的正整数x，满足x=ai(mod mi)或者给出无解
# 4. 同余方程(线性同余方程)： 求关于x的同余方程a*x=1(mod b)的最小正整数解，输入数据保证一定有解

# 2. 线代
# 矩阵乘法
# 1. fibonacci： 求fib(m) mod n的值
# 2. 石头游戏： n行m列的网格上进行石头游戏，每个格子对应一种操作序列，最多10种
# 高斯消元与线性空间
# 1. 开关问题（高斯消元：求解线性方程组的方法)： n个相同的开关，每个开都与某些开关有联系，每当打开或关闭某个开关是，其他于此开关相关联的开关也会相应发生变化
# 2. 球形空间产生器: 快速求解球心坐标
# 3. 装备购买(线性空间)：n件装备，每件都有m个属性，花费c，如何用尽量少的钱买尽量多的装备；如果一件装备的属性能用购买其他装备组合出，那就不必买，花最少的钱买下最多的装备
# 4. xor：n个整数m个询问，每个询问给出一个整数k，求从a序列种选出若干个数执行异或运算能够得到的整数集合中，第k小的整数是多少？

# 3. 组合计数
# 1. 计算系数： 给定一个多项式(ax+by)^k,求出多项式展开后x^n*y^m项的系数，对10007取模
# 2. counting swaps：给定一个1~n的排列p1...pn，可进行若干次操作，每次选择两个整数x,y交换px,py
# 3. 古代猪文: 给定整数q,n; 计算
# 4. 组合计数

# 4. 容斥原理
# 1. Devu and Flowers：n个盒子，每个盒子ni朵花，同一盒子花色相同，选取m朵不同色的花组成一朵，有多少种方案？
# 2. Zap： 5万组询问，每次询问给定三个整数a，b，k；有多少二元组(x,y)，满足x<=a, y<=b,并且gcd(x,y)=k

# 5. 概率与数学期望
# 1. Rainbow的信号: 
# 3. 绿豆蛙的归宿:给出有向无环图，起点为1，终点为N，从起点出发走向终点，等概率选择每条路1/k，路程的路径期望长度？
# 2. 扑克牌：54张牌，随机抽取，得到abcd张黑桃，红桃，梅花，方块需要翻开的牌的张数是期望值E是多少？
# 4. 0/1分数规划： 给定n对整数ai,bi，从中选择出若干对，使选出的数对a之和与b之和的商最大
# 5. 博弈论之SG函数: 三堆硬币，分别包含3，5，7枚，两人轮流行动，每次任选一堆，从中取走多枚，可以取光一堆，但不能不取，取走最后一枚获得胜利；nim博弈，只有先手必败或必胜
# 6. Cutting Game: 给定n*m的矩形网格纸，两名玩家轮流行动，每次行动任选一张矩形网格之，雁阵某一行或某一列的格线，把它剪成两部风，首先检出1*1的玩家获胜，求先手是否必胜

# 6. exp
# 1. Gcd：自定义求公约数函数(线性筛法/ 最大公约数/ 欧拉函数递推)
# 2. gcd求和： Longge's problem(最大公约数/ 欧拉函数/ 积性函数)
# 3. 青蛙的约会：大数gcd (扩展欧几里得)
# 4. Xiao 9 * 大战朱最学： (中国剩余定理) 取余
# 5. 计算器：设计一个计算器，完成 y^z mod p 的值 (线性同余方程/ 高次同余方程)
# 6. matrix power series： 给定n*n的矩阵a和整数k，矩阵平方求和 (矩阵乘法/ 分治)
# 7. 233 Matrix (矩阵乘法/ 分治)
# 8. widget factory (高斯消元/ 同余)：
# 9. xor(线性空间/ 高斯消元/生成树)：求异或
# 10. 新nim游戏(线性空间/ 高斯消元/ 博弈论)
# 11. 排列计数(组合/ 错排问题)：有多少种长度为n的序列a，满足以下条件：1~n，这n个数在序列中个出现了一次
# 12. sky code(容斥原理)
# 14. 守卫者的挑战(概率/ 动态规划)
# 15. 换教室 (数学期望/ 动态规划)
# 16. dropping tests (0/1 分数规划)
# 17. 魔法珠 (博弈论/ sg函数)
# 18. Georgia and Bob (博弈论)

# ######################################################################
# 高级数据结构(37)：
# 1. 并查集: 动态维护若干个不重叠的集合，并支持合并与查询的数据结构(get:查询一个元素属于哪个集合；merge：把两个集合合并成一个大集合)
# 1. 程序自动分析(路径压缩与按秩合并)： 给定约束满足问题，分别对它们进行判定
# 2. Supermarket： 给定n个商品，每个商品有利润pi和过期时间di，每天只能卖一个商品，过期商品不能再卖，如何安排每天卖的商品，可以使收益最大，二叉堆； 并查集配合贪心
# 3. 银河英雄传说(扩展域与边带权的并查集)：n个战场，n艘战舰；m条指令mij让第i号战舰所在的列全部战舰保持原有顺序，接在第j号战舰所在列的尾部；cij询问i号战舰与j号战舰当前是否处于同一列中。如果在同一列，之间间隔了多少艘战舰
# 4. ParityGame：a和b玩游戏，
# 5. 食物链：三种动物，a吃b，b吃c，c吃a；有n个动物，每个属于abc中的一种，用两种说法对n个动物构成的食物链关系进行描述：k句话，有真有假，根据给定的n和k句话，输出假话的总数

# 2. 树状数组： (基于二进制划分和倍增)维护序列的前缀和，对于给定的序列a，建立一个数组c，其中c[x]保存序列a的区间[x-lowbit(x) + 1, x]中所有数的和
# 1. 楼兰图腾(树状数组与逆序对)：平面上n个点，每个点的横纵坐标的范围都是1~n，任意两点的横纵坐标都不相同，三个点满足x1<x2<x3,且y3>y2,y1>y2构成v字，或倒v，求两类图腾的个数
# 2. A simple with Integers(树状数组的扩展应用)：长度为n的数列a，输入操作指令：C|r d 把数列中第l~r个数都加d，第二类指令Q|r 询问数列中第l~r个数的和
# 3. lost cows： n头牛，身高各不相同，n头牛站成一列，已知第i头牛前面有ai头比它低，求每头牛的身高

# 3. 线段树： 基于分治思想的二叉树结构，由于在区间上进行信息统计，与按照二进制位(2的次幂)进行区间划分的树状数组相比，线段树是一种更加通用的结构
# 1. can you answer on these queries： 长度为n的数列a，m条指令：1 x y查询区间[x,y]中的最大连续子段和； 2 x y 把A[x]改成y，对于每个询问，输出一个整数表示答案
# 2. interval GCD： 长度为n的数列a，m条指令，C|r d 把A[l], A[l+1], A[r]都加上d；Q|r表示询问A[l],A[l+1],...,A[r]的最大公约数GCD,对于每个询问，输出一个整数表示答案
# 3. a simple problem with integers(延迟标记)(给定长度为n的数列a，输入操作指令：C|r,d 把数列中第l~r个数都加d；第二类指令：Q|r，询问数列中第l~r个数的和)
# 4. atlantis(扫描线)(给定平面直角坐标系中的n个矩形，求它们的面积，这些矩形的并集在坐标系中覆盖的总面积)
# 5. stars in your window(天空中很多星星，已知每颗星星的坐标和亮度，求用宽为w，高为h的矩形，能圈住的星星的亮度总和最大是多少？矩形边界上的星星不算)
# 动态开点与线段树合并

# 4. 分块，点分治： (通过适当的划分，预处理一部分信息并保存，用空间换取时间，达到时空平衡)
# 1. a simple problem with integers(给定长度为n的数列a，输入操作指令，C|r d把数列中第l~r个数都加d；Q|r询问数列中第l~r个数的和)
# 2. 蒲公英： 所有的蒲公英为一个长度为n的序列，ai表示第i颗蒲公英的种类编号。有m次询问，每次询问一个区间[x,y],需要回答[ax,...ay]中出现最多的是哪种蒲公英，如果有若干种蒲公英出现次数相同，则输出种类编号最小的那个，算法必须在线
# 3. 磁力块： n块磁石，每块用五元组表示(x,y,m,p,r)，x,y表示坐标，m表示磁石的质量，p是磁力，r是吸引半径，在x0,y0出持有一块磁石，最多吸引多少磁石，可以使用吸引到的磁石
# 4. 小z的袜子： n只袜子，从l到r的袜子中随机选出两只来穿，尽管不在意两只袜子是不是完整的一双，却很在意袜子的颜色，毕竟两只不同色的袜子会很尴尬；告诉z有多大的概率抽到两只颜色相同的袜子
# 5. Tree(点分治): n个节点的树，每条边都有一个权值，树上的两个节点x和y之间的路径长度就是路径上个边的权值之和。求长度不超过k的路径有多少条?

# 5. 平衡树：bst二叉查找树每个节点的关键码：不小于它左子树中任意节点的关键码；不大于它右子树中任意节点的关键码
# 1. Treap： bst很容易退化，为了维持平衡，有了各种平衡树；改变并保持bst性质的方法就是旋转(splay 伸展树灵活多变，应用广泛，可以方便的支持各种动态的区间操作，用于解决复杂问题的高级数据结构)

# 6. 离线分治(时间轴：查询，修改对应的时间不同)
# 1. 天使玩偶(基于时间的分治：对操作序列中每个查询，计算结果等价于计算初始数据以及之前的所有修改对该查询造成的影响)
# 2. k-th number(基于值域的分治：给定一个长度为n的整数序列a和固定整数s，执行m次操作，每次操作输入三个整数，格式为以下两种：0|r一次查询；1xy一次修改；m个形如查找序列a中第l到第r个数中第k小的数)

# 7. 可持久化数据结构(每次操作结束后，创建数据结构中发生改变的部分的副本，高效的记录一个数据结构的所有历史状态)
# 1. 最大异或和(可持久化trie)： 给定一个非负整数序列a，初始长度为n，有m个操作，每个操作两种类型：Ax添加操作，序列末尾插入一个数，序列长度N增大1；q|rx询问操作，求一个位置p满足l<=p<=r 使得a[p]xora[p+1]xor...[x]最大
# 2. k-th number(可持久化线段树)

# 8. exp
# 1. 关押罪犯(并查集/ 扩展域或边带权)，使得数对间的权值和最小
# 2. rochambeau game(并查集/ 扩展域或边带权)：n个人，1人做裁判，n-1分成3组，通过组间的判断，推测出谁是裁判
# 3. True Liars(并查集 + 背包)
# 4. Buy tickets (树状数组)
# 5. hotel：(线段树 / 延迟标记)
# 6. Picture(扫描线)：给定二维数组表示平面内坐标，计算平面中长方形的个数：每个长方形只按照水平或垂直摆放：
# 7. 作诗(分块)： n个数，每次问[l,r]中有多少个数出现偶数次？
# 8. Race(点分治)： 给定一棵树，每条边有权，求一条简单路径，权值和等于k，且边的数量最小，返回最小边数量
# 9. 营业额统计(平衡树/  treap）：给定数组，统计数组元素的累积波动值
# 10. 自顶向下Splay解法(平衡树 / splay)： 
# 11. Mokia(基于时间的分治算法)：子矩阵元素求和
# 12. Meteors(基于值域的整体分治算法)：
# 13. Fotile模拟赛(分块+ 可持久化Trie)：给定长度为n的序列a，计算某些区间内的最大的连续xor和
# 14. 可持久化并查集加强版(可持久化线段树 + 并查集按秩合并)：

# #######################################################################
# 动态规划(69)
# 1. 线性dp： 从初态开始，沿着阶段的扩张向某个妨碍给你递推，直至算出目标状态 (lis, lcs, triangle) 最长上升子序列；最长公共子序列；三角形矩阵每次向下或向右移动，最大路径和；
# 1. Mr. Young's Picture Permutations(n个学生排k行队，左端对齐，身高从左到右，从上到下递减，共多少种排队方式，数字三角形排列)
# 2. LCIS: 最长公共上升子序列(求两个数列的最长公共上升子序列)
# 3. making the grade(给定序列a，构造长度为n的序列b，满足：b非严格单调，可以递增也可以递减，有重复元素；sum(ai-bi)的值最小)；至少需要修改多少个数？
# 4. mobile service(指派三个员工到三个地方，指派代价矩阵c(p,q),要求同一时刻只能移动一个员工；相同位置不能有两个员工，按顺序依次指派员工，求最小代价)
# 5. 传纸条(矩阵中移动，每步只能向右或向下，求最大和 要求：两条路径，重复的点位只能算一次)
# 6. I-country： 矩阵中最大凸连通块
# 7. Cookies: m个饼干，n个孩子，gi为孩子的贪婪度，如果有ai个孩子拿到的饼干比第i个孩子多，第i个孩子的怨气为gi*ai，要求每人最少一块饼干，最小怨气的分配方案

# 2. 背包问题： 总体积不超过最大容量时的最大价值
# 1. 数字组合(0/1背包，n个物品，体积价值矩阵为[v,w],容器容量m，不超过最大容量的物品的最大价值正整数序列中子序列和为m的子序列数；n个数，子序列和为m的选择方案数)
# 2. 自然数拆分Lunatic版(完全背包，n种物品，有无数个，求最大价值)(自然数n拆分成若干个正整数相加的形式，参与加法运算的数允许重复，求拆分方案数)
# 3. Jury Compromise(n个候选人，m个席位，控方分数d，辩方分数p，总分差绝对值最小，方法不唯一时，选择分值和最大的方案)
# 4. Coins(多重背包，n种物品，每种c个，求最大价值；n种硬币，面值ai，数量ci，选出若干面值和为s，求1~m间能被拼成的面值有多少？)
# 5. 分组背包(n组物品，每组c个，每个价值矩阵[v,w],求最大价值)

# 3. 区间dp：以区间长度作为dp的阶段，使用两个坐标描述每个维度，决策就是划分区间的方法，向下划分，再向上递推，类似线段树
# 1. 石子合并：n堆石子，每次合并相邻的两堆，体力消耗为合并的石子重量和，将n堆石子合并为1堆的最小体力消耗
# 2. Polygon(n边形游戏，第一步删除一条边，之后每一步删除一条边形成的新的节点的值为删除边形成的新的节点的值为删除边及两个端点的节点值计算结果，求最后的最大得分)
# 3. 金字塔：(给定字符串，abababa对应5种金字塔结构，多叉树dfs序对应的树的结构数)

# 4. 树形dp： n叉树，对每个节点x，递归在每个子节点上进行dp，回溯时，从子节点向节点x进行状态转移
# 1. 没有上司的舞会(树形职员关系，没有职员与直接上司参加，职员最大快乐值之和hi)
# 2. 选课(背包类树形dp， 选课学分最多，课程直接先修课最多一门，限制：每门课的先修课程只有一门，两门课的先修课称允许相同，课程不存在时间冲突)
# 3. Accumulation degree(二次扫描与换根，源点和汇点构成n叉树，节点x,y的容量为c(x,y),流量不超过河道容量，哪个点作为源点时整个水系流量最大)

# 5. 环形与后效性处理
# 1. naptime(环形结构动态规划)： i个小时睡觉回复ui点体力，每天n个小时，需要休息8个小时，回复最多体力
# 2. 环路运输： 环形公路，n座仓库，仓库存量ai，两座仓库送货成本ai+aj+dist(i,j),求最大送货成本的两座仓库
# 3. broken robot(有后效性的状态转移方程)：n*m的棋盘，机器人多轮滚动，等概率停留在原地，左右下移动一格，从起点移动到最后一行的任一位置所需行动次数的数学期望值

# 6. 计数类dp: 计数问题，强调不重，不漏
# 1. Gerald and Giant Chess (H*W的棋盘，只有N个格子黑色，左上角到右下角每一步只能向右或向下一格，不能移动到黑色格子中，一共有多少种可能的路线)
# 2. Connected Graph (求N个节点的无向连通图有多少个)
# 3. How many of them (无向连通图中，若一条边被删除后，图会分成不连通的两部分，称该边为割边，求满足条件的无向连通图数：由n个节点构成；割边不超过m条；没有自环和重边)
# 4. A Decorative Fence (N块木板组成长度为N的栅栏，构建栅栏的方案按字典序排序，排名为C的栅栏中各木板从左到右的长度)

# 7. 数位统计dp
# 1. 启示录： (求第x小的魔鬼数，数字的十进制表示中有三个连续的6)
# 2. 月之迷： (求给定区间内的月之数个数，一个十进制数能被它的各位数字之和整除)

# 8. 状态压缩优化
# 1. Mondriaan's Dream：（N* M的棋盘分割成若干个1*2的长方形，有多少种方案）
# 3. 炮兵阵地：(N*M 矩阵平面，炮兵阵地攻击上下左右两个距离，不误伤的前提下，最多部署多少阵地)
# 2. 宝藏：（N个宝藏，M条道路，工程代价最小,避免重复，道路构成一颗树，代价为节点间距离*根节点到目标节点间所有节点数）

# 倍增优化
# 2. 开车旅行 （AB行程总数比值最小；行驶的总路程）
# 1. count the repetitions： 给定两个字符串s1，s2；两个整数n1，n2；求最大整数m，满足(conn(conn(s2,n2),m) 能由conn(s1,n1))生成，s1和s2长度不超过100，n1 n2不大于10^6

# 9. 数据结构优化
# 1. cleaning shifts：(线段树维护花费的最小代价) （白色纸带长度为l，n条贴纸，第i条贴纸可以覆盖ai到bi个格子，售价为ci，若干条贴纸覆盖L-R个格子的最少花费）
# 2. the battle of chibi：(平衡树复杂，树状数组维护前缀和) (长度为N的数列A，有多少个长度为M的严格递增子序列)

# 单调队列优化： 决策取值范围上下界均单调变化每个决策在候选集合中插入或删除最多依次的问题； 单调队列优化多重背包
# 1. cut the sequence: (长度为n的序列A，把序列分成若干段，在满足每段种所有数的和不超过M的前提下，每段中所有数的最大值之和最小，求该最小值)
# 2. Fence (N块木板从左到右拍成一行，M个工匠依次粉刷，每块木板最多刷一次，第i个工匠要么不刷，要么刷包含木板Si，长度不超过Li的连续的一段木板，每刷一块可以得到Pi的报酬，安排总报酬最多)

# 斜率优化： 多项式val(i,j)中的每一项仅与i和j中的一个有关使用单调队列优化，包含i，j的乘积项时的优化方式
# 1. Cat Transport (M只猫，P位饲养员，N座山，第i只猫去Hi号山玩到Ti时刻停止等接，猫的等待时间为0或1，规划饲养员出发时间，使每只猫的等待时间最短)
# 2. 任务安排 （N个任务分成若干批依次执行，第i个任务的执行时间Ti,每批任务开始前需要S的启动时间，执行一批任务所需的时间是启动时间S加每个任务所需时间之和

# 四边形不等式： w(a,d) + w(b,c) >= w(a,c) + w(b,d)
# 2. 诗人小G （一维dp） （诗句不协调度尽量小，实际长度与行标准长度差值绝对值的P次方，求最小的不协调度）
# 1. old stone game （二维dp）(区间和，满足四边形不等式，在p[l,r-1] <= k <= p[l+1,r]的范围内对k进行枚举)

# 10. exp
# 1. 乌龟棋(一行n个格子的棋盘，每格一个权值，从起点到终点4中走法，求最大分数)： 线性dp
# 2. 花店橱窗(二维矩阵表示：花在特定花瓶中的美观度，求最大的美观度)： 线性dp
# 3. buy low buy lower(一维数组表示股价序列，统计最长递减子串) 线性dp/统计LIS方案数
# 4. trip (两个字符串，统计最长公共子串) 线性dp/统计LCS方案数
# 5. substract(数组间元素相减，相减元素坐标由题目给出，求解特定target需要的相减规则) 线性dp
# 6. 陨石的秘密(陨石的秘密 线性dp; l1 l2 l3 分别代表{} [] (), 求解三种操作对数组的运算结果)线性dp
# 7. 划分大理石(价值分别为1...6的大理石各a[1...6]块，将它们分成两部分，是两部分价值之和相等，是否可以实现？大理石总数不超过20000) 背包/多重背包
# 8. Folding(给定字符串，将连续字符计数后压缩) 区间dp
# 9. 能量项链(特定的珠子顺序，使得珠子首尾相连，释放最大能量)： 区间dp/环拆链并复制一倍
# 10. 棋盘分割(分割8*8的棋盘，使得各矩形棋盘总分的均方差最小)： 区间dp/二维平面上的区间dp
# 11. Blocks(四种颜色的金属块排成一列，相同颜色的相邻金属块合并得分为个数的平方，求一列色块的最大得分)： 区间dp
# 12. Strategic game(n叉树中使用最少节点可以与所有节点相连)： 树形dp
# 13. Bribing FIPA(拥有附属关系的国家无需贿赂，求最少的贿赂数量): 树形dp/背包树形dp
# 14. Computer(求得树中所有节点到其最远节点的距离)： 树形dp/二次扫描与换根法
# 15. xor和路径()： 有后效性dp/高斯消元/数学期望
# 16. Islands and bridges(找出图中包含最多三角形的hamilton路径): 状态压缩dp
# 17. corn fields(矩形农场种玉米，不能相邻块种植，，可选择的种植方案数)： 状态压缩dp/ 填充网格图形
# 18. bugs integrated inc(裁剪二维矩阵，避开bug区域，使得裁剪面积尽可能大)： 状态压缩dp/ 填充网格图形
# 19. fence obstacle course()： 线段树优化dp
# 20. estimation()： 堆优化dp/中位数
# 21. 干草堆(给定数组表示干草堆宽度，求解层层叠加的最高高度)： 单调队列优化dp/ 贪心
# 22. 股票交易(给定股价序列，带交易冻结期，求最大profits)： 单调队列优化dp
# 23. largest submatrix(相同字符的最大子矩阵数)： 单调队列优化dp
# 24. k-anonymous sequence()： 斜率优化
# 25. 特别行动队(给定数组表示行动队员战斗力，将相邻队员合并组队使得整体战斗力最大)： 斜率优化
# 26. post office(数轴上建office到所有villages的距离之和最小)： 四边形不等式
# 27. 扑克牌(52张扑克牌，相邻牌面值不同的排列方案数)： 计数类dp
# 28. the counting problem(统计区间内各个数字的出现次数)： 数位统计dp
# 29. round numbers(统计区间内round numbers的个数)： 数位统计dp
# #######################################################################
# 图论(73)
# 1. 最短路: 节点间的最短路径长度
# 1. telephone line: (单源最短路,dijkstra, bellman-ford&SPFA) n座基站，p条双向电缆，i条电缆花费li，求最小花费
# 2. 最优贸易(n个城市m条路，每个城市水晶球价格，最多赚多少旅费)
# 3. 道路与航线(带负权边的单源最短路)： (单源最短路)
# 4. cow replays()： (任意两点间的最短路径, 求解n次单源最短路问题；稠密图使用floyd算法) t条边构成的无向图，求从起点s到终点e恰好经过n条边的最短路
# 5. sightseeing trip(): (任意两点间的最短路径) 无向图中求一个至少包含3个节点的环，环上的节点不重复，并且环上的边的长度之和最小
# 6. sorting it all out()： n个变量，m个不等式，不等式间具有传递性，判断不等式间是否有矛盾，能否确定每对变量的大小关系？

# 2. 最小生成树： 带边权无向图的连通子图权重和最小的生成树（kruskal维护无向图的最小生成森林；prim维护最小生成树的一部分)
# 1. 走廊泼水节: n个节点是树，扩充为完全图，满足凸的唯一最小生成树不变，求增加的边的权值和最小是多少
# 2. picnic planning： n个节点m条边的无向图，求出该图的最小生成树，满足1号节点的度数不超过给定的整数s
# 3. 最优比率生成树：边权值为数对[c,r], 求最小生成树 sum(c)/sum(r)最小
# 4. 黑暗城堡

# 3. 数的直径和最近公共祖先： 树中最远的两个节点之间的距离称为树的直径；两个节点公共祖先中深度最大
# 1. 巡逻(树的直径： 树形dp求树的直径； 两次BFS求树的直径；n个节点，遍历所有节点的最短路径)
# 2. 树网的核(树的直径：给定有向无环图，求一个路径，某直径上的一段路径，长度不超过s，使得偏心距最小，称其为 )
# 3. 音的连锁 (树上差分)
# 4. 雨天的尾巴 (树上差分)
# 5. 天天爱跑步 (树上差分)
# 6. 异象石(lca的综合应用)
# 7. 严格次小生成树 (lca的综合应用)
# 8. 疫情控制 (lca的综合应用)

# 4. 基环树，负环与差分约束: (n个点n条边的连通无向图：在树上加`一条边构成的恰好包含一个环的图称为“基环树”。如果不保证连通，那么n个点n条边的无向图也可能是若干基环树组成的森林，简称为“基环树森林”)
# 3. 岛屿：n个节点，不重复的遍历完所有节点能够移动的最长距离
# 2. 创世纪： n中元素，每种元素可以限制另外一种，第i种可以限制元素ai，最多放置多少种元素
# 1. freda的传呼机： n个节点的无向连通图，m条边，讨论三种情况计算q对节点间的距离：n-1条边(无环)；n条边(一个环);每条光缆仅在一个环中
# 5. sightseeing cows(负环：图中存在一个环，环上的权值之和是负数); 有向图节点权值fi，边权值ti，求图中的一个环，使得环上个点的权值之和除以环上各边的权值之和最大，输出该值
# 4. interval(差分约束：n元一次不等式组，n个变量，m个约束条件，求一组解，是所有约束条件都得到满足；每个约束条件类似于单源最短路中的三角不等式)(n个闭区间，n个整数。使得整数集合中属于闭区间内的数不少于c个，求这样的整数集合最少包含多少个数)
 
# 5. tarjan 算法与无向图连通性(tarjan算法可以在线性时间内求出无向图的割点和桥，进一步可以求出无向图的双连通分量)
# 1. blo(n个节点m条边的无向连通图，输出n个整数，i个整数表示去掉i节点的所有边之后，无向图中有多少个有序点对不连通)
# 2. network(无向图的双连通分量，n个节点m条边的无向连通图，q次操作，每次向图中添加一条边，询问当前无向图中桥的数量)
# 3. knights of the round table(n个骑士安排圆桌，m对憎恨关系，憎恨的骑士不相邻，要求安排奇数个骑士；满足要求安排，至少踢掉多少个骑士)
# 4. watchcow(欧拉回路，一笔画问题：n个节点m条边，求一条路径，从节点1出发回到节点1，满足买条边恰好被沿着正反两个方向分别经过一次，输出所有方案)

# 6. tarjan算法 与有向图连通性(tarjan 能够求出有向图的强连通分量，必经点和必经边)
# 1. network of school(强连通图：对于有向图中的任意两个节点能够相互抵达，极大强连通子图被称为强连通分量)(n个节点的有向图染色，至少需要染色几个节点才能将所有节点染色，至少添加多少个连接关系，才能变成强连通图)
# 2. 银河(n颗恒星，m对亮度的相对关系，最暗的是1，求n颗恒星的亮度值最少？)
# 3. PKU ACM Team's Excursion(有向图的必经点和必经边：n个节点m条边的有向无环图，每条边都有一个长度，给定起点s和终点t，从s到t的每条路径都经过某条边，定义从s到t的危险程度等于步行经过桥上的路段长度之和，求最小危险程度)
# 4. katu puzzle(2-SAT, n个变量取值为0或1，m个算式，每个算式形如xa op xb = c; a,b 是对每个变量的编号，c是数字0或1， op是and or xor 三个位运算之一，是否存在对每个变量的合法赋值，使所有算式都成立)
# 5. Priest John's Busiest Day(安排n个时间段，时长di，起始时间si，ti， 要求所有时间段不重叠的方案)

# 6. 二分图匹配(n个节点的无向图分成a b 两个非空结合，其中 a∩b=空集，并在同一集合内的点之间没有边相连，称这张图为一张二分图，a，b分别称为二分图的左部和右部)
# 1. 关押罪犯(二分图判定，n个罪犯分到两个监狱，给定两名罪犯间的怨气值，求分配方案使得最大的怨气值最小)
# 2. 棋盘覆盖(二分图匹配，n行m列棋盘，有禁入格点，求最多往棋盘上放多少个长度为2，宽度为1的骨牌，要求任意两张骨牌不重叠)
# 3. 车的放置(棋盘内最多放置多少个中国象棋中的车)
# 4. 导弹防御塔(n座防御塔的坐标，m个入侵者坐标，t1导弹射出时间，t2防御塔冷却时间，v导弹匀速；至少需要多少分钟才能击退所有入侵者)
# 5. Ants(平面上2n个点，n个百点，n个黑点。对于每个白点，找到一个黑点把二者用线段连起来，要求所有线段不相交，求一种方案，数据保证有解， n<=100)

# 7. 二分图覆盖与独立集(二分图最小的点集s，使得图中任意一条边都至少有一个端点属于s，这个问题称作二分图的最小点覆盖)
# 1. machine schedule：a，b两台机器和n个任务，每台机器有m种不同的模式；对于每个任务i，给定两个整数ai，bi；如果该任务在a上执行，设置模式为ai，在b执行，设置模式为bi；任务可以以任意顺序被执行，每台机器切换一次模式需要重启一次，如何分配任务安排顺序，使机器重启次数最少？
# 2. muddy fields：n * m 的网格状地面，有些格子泥泞，有些格子干净。用宽度为1，长度任意的木板把泥地盖住，不能盖住干净的地面，每块木板必须覆盖若干完整格子，木板可以重叠，最少需要多少块木板？
# 4. 骑士放置(二分图最大独立集，n*m的棋盘，带禁入点，中国象棋中的马，最多放置多少个不会相互攻击)
# 3. Vani 和 cl2 捉迷藏(有向无环图的最小路径点覆盖:用尽量少的不相交的简单路径覆盖有向无环图的所有顶点：每个顶点恰好被覆盖一次)(n个节点，m条有向边的无环图，最多选出多少个节点，节点间互不相连)

# 8. 网络流初步： 有向图，边权代表容量，特殊的起始点源点和汇点，
# 1. 舞动的夜晚(最大流：两组人n,m; 组间人相互认识的为e对，不可重复牵手，那些人之间牵手会使最大牵手对数减少？)
# 2. cable TV Network(最小割:最大流量等于最小割中边的容量之和：给定一张无向图，最少去掉多少个点，可使图不连通，)
# 3. k取方格数(费用流：增加单位费用限制，最小&大费用最大流，n*n的矩阵，左上角到右下角安排k条线路，多条线路重复经过一个格子只取一次，求能取得的整数的和最大是多少？)

# 9. exp
# 1. sightseeing: 最短路/ 单源次短路及其条数
# 2. 升降梯上： 最短路/ 节点扩散到二维
# 3. GF和猫咪的玩具： 最短路/ 任意两点间最短路
# 4. 社交网络：最短路/ 任意两点间最短路及其条数
# 5. Arctic Network： 最小生成树
# 6. 四叶草魔杖：最小生成树/ 状态压缩，动态规划
# 7. 直径： 树的直径的必须边
# 8. 逃学的小孩： 数的直径
# 9. 聚会： 最近公共祖先
# 10. rendezvous： 基环树/ 最近公共祖先
# 11. cashier employment： 差分约束
# 12. 最优高铁换： 负环判定/ 01分数规划
# 13. redundant paths： tarjan算法/ 桥
# 14. 矿场搭建： tarjan算法/ 割点
# 15. 逃不掉的路：边双连通分量/缩点/无向图必经边
# 16. traffic real time query system： 点双连通分量/ 缩点/ 无向图必经点
# 17. john's trip: 欧拉路
# 18. going from u to v from v to u： 强连通分量/ 缩点
# 19. 杀人游戏： 强连通分量/ 缩点
# 20. planar： 2-SAT
# 21. wedding: 2-SAT/输出方案
# 22. team them up： 二分图判定/ 动态规划
# 23. place the robots： 二分图最大匹配
# 24. steady cow assignment： 二分图多重匹配
# 25. going home： 二分图带权匹配
# 26. air raid： 二分图最小路径点覆盖
# 27. sorting slide： 二分图最大匹配的必须边
# 28. king‘s quest： 二分图最大匹配的可行边
# 29. drainage ditches： 最大流