# https://time.geekbang.org/column/intro/139
# https://blog.csdn.net/weixin_49258262/article/details/123993721

# 基础篇
# 1. 基础架构： 一条SQL查询语句如何执行
#### 连接器
#### 查询缓存
#### 分析器
#### 优化器
#### 执行器

# 2. 日志系统： 一条SQL更新语句如何执行
#### 重要的日志模块：redo log
#### 重要的日志模块：binlog
#### 两阶段提交


# 3. 事务隔离： 为什么你改了我还看不见
#### 隔离性与隔离级别
#### 事务隔离的实现
#### 事务的启动方式


# 4. 深入浅出索引(n叉树， 跳表， lsm 数据模型)
#### 索引的常见模型
#### InnoDB 的索引模型
#### 索引维护

#### 覆盖索引
#### 最左前缀原则
#### 索引下推


# 5. 全局锁和表锁： 给表加个子段怎么有这么多阻碍
#### 全局锁
#### 表级锁


# 6. 行锁功过： 怎么减少行锁对性能的影响
#### 从两阶段锁说起
#### 死锁和死锁检测


# 7. 事务到底是隔离还是不隔离
#### “快照”在 MVCC 里是怎么工作的？
#### 更新逻辑


# #############################################################################

# 实践篇
# 1. 普通索引，唯一索引如何选择
#### 查询过程
#### 更新过程
#### change buffer 的使用场景
#### 索引选择和实践
#### change buffer 和 redo log

# 2. MySQL为什么有时会选错索引
#### 优化器的逻辑
#### 索引选择异常和处理

# 3. 如何给字符串字段加索引
#### 前缀索引对覆盖索引的影响
#### 其他方式

# ############################################
# 4. 为什么我的MySQL会 “抖” 一下
#### 你的 SQL 语句为什么变“慢”了
#### InnoDB 刷脏页的控制策略

# 5. 为什么表数据删掉一半，表文件大小不变
#### 参数 innodb_file_per_table
#### 数据删除流程
#### 重建表
#### Online 和 inplace

# ############################################
# 6. count(*)为什么慢？如何处理
#### count(*) 的实现方式
#### 用缓存系统保存计数
#### 在数据库保存计数
#### 不同的 count 用法


# 7. 日志和索引相关问题


# 8. order by 如何工作
#### 全字段排序
#### rowid 排序


# 9. 如何正确显示随机消息
#### 内存临时表
#### 磁盘临时表
#### 随机排序方法

# 11. 为什么SQL语句逻辑相同，性能却差异巨大
#### 案例一：条件字段函数操作
#### 案例二：隐式类型转换
#### 案例三：隐式字符编码转换

# 12. 为什么只查一行语句，也执行这么慢
#### 第一类：查询长时间不返回
#### 第二类：查询慢

# 13. 幻读是什么？有什么问题
#### 幻读是什么？
#### 幻读有什么问题？
#### 如何解决幻读？

# 14. 为什么只查一行语句，锁这么多
#### 案例一：等值查询间隙锁
#### 案例二：非唯一索引等值锁
#### 案例三：主键索引范围锁
#### 案例四：非唯一索引范围锁
#### 案例五：唯一索引范围锁 bug
#### 案例六：非唯一索引上存在"等值"的例子
#### 案例七：limit 语句加锁
#### 案例八：一个死锁的例子

# #################################################
# 15. MySQL有哪些 提高性能的方法
#### 短连接风暴
#### 慢查询性能问题
#### QPS 突增问题

# 16. 
#### binlog 的写入机制
#### redo log 的写入机制
#### 循环复制问题


# ###################################################
# 16. 如何保证主备一致
#### MySQL 主备的基本原理
#### binlog 的三种格式对比
#### 为什么会有 mixed 格式的 binlog？

# 17. 如何保证高可用
#### 主备延迟
#### 主备延迟的来源
#### 可靠性优先策略
#### 可用性优先策略


# 18. 备库为什么会延迟好几个小时
#### 并行复制策略

# 19. 主库出问题，从库怎么办
#### 基于位点的主备切换
#### GTID
#### 基于 GTID 的主备切换
#### GTID 和在线 DDL

# 20. 读写分离有哪些坑
#### 强制走主库方案
#### Sleep 方案
#### 判断主备无延迟方案
#### 配合 semi-sync
#### 等主库位点方案
#### GTID 方案


# 21. 如何判断一个数据库是否出了问题
#### select 1 判断
#### 更新判断
#### 内部统计

# 22. 用动态的观点看锁


# 23. 误删数据处理
#### 误删行
#### 误删库 / 表
#### 延迟复制备库
#### 预防误删库 / 表的方法
#### rm 删除数据

# 24. 为什么有kill不掉的语句
#### 收到 kill 以后，线程做什么？
#### 另外两个关于客户端的误解


# 25. 查这么多数据，会不会把数据库内存打爆
#### 全表扫描对 server 层的影响
#### 全表扫描对 InnoDB 的影响


# ##################################################
# 26. 可以使用join吗
#### Index Nested-Loop Join
#### Simple Nested-Loop Join
#### Block Nested-Loop Join

# 27. join语句如何优化
#### Multi-Range Read 优化
#### Batched Key Access
#### BNL 算法的性能问题
#### BNL 转 BKA
#### 扩展 -hash join

# 28. 为什么临时表可以重名
#### 临时表的特性
#### 临时表的应用
#### 为什么临时表可以重名？
#### 临时表和主备复制

# 29. 为什么会使用内部临时表
#### union 执行流程
#### group by 执行流程
#### group by 优化方法 -- 索引
#### group by 优化方法 -- 直接排序

# 30. InnoDB好，还要使用Memory引擎吗
#### 内存表的数据组织结构
#### hash 索引和 B-Tree 索引
#### 内存表的锁
#### 数据持久性问题

# 31. 自增主键为什么不连续
#### 自增值保存在哪儿？
#### 自增值修改机制
#### 自增值的修改时机
#### 自增锁的优化

# 32. insert 语句的锁为什么这么多？
#### insert … select 语句
#### insert 循环写入
#### insert 唯一键冲突
#### insert into … on duplicate key update

# 33. grant 之后要跟着 flush privileges吗
#### mysqldump 方法
#### 导出 CSV 文件
#### 物理拷贝方法

# 34. 如何最快地复制一张表
#### 全局权限
#### db 权限
#### 表权限和列权限
#### flush privileges 使用场景

# 35. 要不要使用分区表
#### 分区表是什么？
#### 分区表的引擎层行为
#### 分区策略
#### 分区表的应用场景

# 36. 递增id用完如何处理
#### 表定义自增值 id
#### InnoDB 系统自增 row_id
#### Xid
#### Innodb trx_id
#### thread_id