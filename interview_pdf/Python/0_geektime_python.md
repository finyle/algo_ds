# https://time.geekbang.org/column/intro/176?from=trial&tab=catalog

# #######################################################################
# 基础
# 1. 列表和元组
```
list []
tuple ()
```
# 2. 字典，集合
```
dict {}
set ()
```
# 3. 字符串

# 4. Python 输入与输出
```
input()
sys.stdin()
```

# 5. 条件与循环
```
 if else
 for range, itertools
```

# 6. 异常处理：提高程序稳定性
```
# 1. python内置异常doc： https://docs.python.org/3/library/exceptions.html#bltin-exceptions
# 2. 如何处理异常： 
## 通常 try & except: 注意：程序中存在多个except block时，最多只有一个except block会被执行：多个except声明的异常类型都与实际相匹配，只有最前面的except block被执行，其他忽略
# 3. 用户自定义异常：
## Python 内置异常类型：Exception
# 4. 异常的使用与注意点:
## 不确定代码是否能正确执行，也无法请轻易判断
```

# 7. 自定义函数
```
# 0. Python函数：可以自定义默认参数值
# 1. 合理使用函数嵌套，能够提升代母执行效率：输入检查不是很快，还会耗费一定资源
# 2. 函数变量作用域： 函数内部为局部变量值，函数执行完成后变销毁
# 3. 闭包：类似嵌套函数：嵌套函数的外部函数返回一个函数，而不是个具体的值
```

# 8. 匿名函数
```
# 1. 匿名函数基础： 关键字lambda; lambda arg1, arg2, ... : expression
## 1.1 lambda 是一个表达式，并不是一个语句， 所以可以用在一些常规函数def不能用的地方： 
[(lambda x: x * x)(x)for x in range(10)]
### 用作某些函数的参数
l = [(1, 20), (3, 0), (9, 10), (2, -1)]
l.sort(key = lambda x: x[1]); print(l)

## 1.2 lambda的主体是只有一行的简单表达式，并不能扩展成一个多行的代码块
### lambda 的发布主旨：让它与常规函数各司其职, 只专注于简单任务

# 2.为什么使用匿名函数：
## 减少代码复杂度

# 3.Python函数式编程：代码中的每一块都是不可变的(immutable), 都由纯函数的形式组成，纯函数：本身相互独立，互补影响，对于相同的输入，总会有相同的输出，没有任何副作用
## map, reduce, filter
```

# 9. 面向对象
```
# 1. 类： 一群有着相同属性和函数的对象的集合： 封装，继承，多态
# 2. 如何在一个类中定义一些常量，每个对象都可以方便的访问这些常量而不用重新构造
# 3. 如果一个函数不涉及到访问修改这个类的属性，放在类外不恰当，如何做才能更优雅
# 4. 一群相似的类的集合：继承
# 5. 抽象类：不能实例化，只能作为父类：定义接口；抽象方法：@abstractmethod修饰
# 6. 构造一个搜索引擎：理清所有类的属性和函数的继承关系
## 搜索器； 索引器； 检索器； 用户接口

# 软件设计原则： 开闭，依赖倒置，里氏替换， 单一职责， 接口隔离
```

# 10. Python 模块化
```
# 1. 简单模块化： 将函数，类，常量分解不同文件，把它们放在同一个文件夹， 使用 from file import function_name, class_name 的方式调用
# 2. 项目模块化： 相对位置优于代码迁移，不雅观且易出错； 大型工程中使用绝对位置；对于独立项目，所有模块的追寻方式最好从项目的根目录开始追溯
# 3. if __name__ == "__main__": 避开import 执行
## __name__作为python的魔术内置参数，本质是模块对象的一个属性，使用import语句时，__name__就会被赋值为该模块的名字
```

# 11. 列表和元组的内部实现
```
# 1. 列表和元组的内部实现
## 本质都是array
# 2. 为什么在旧哈希表中，元素会越来越稀疏？
# 3. 异常： 在异常处理的except block中，把异常赋予一个变量，这个变量会在except block执行结束时被删除
# 4. 关于多态和全局变量的修改

```
# ####################################################################
# 进阶
# 12. Python 对象的比较，拷贝
```
# 深拷贝和浅拷贝：
# 1. '==' & 'is': 对象比较的两种常用方式：前者比较对象之间的值是否相等；后者比较对象的身份标识是否相等(它们是否是同一个对象，是否指向同一个内存地址

# 2. 浅拷贝和深度拷贝
## 浅拷贝(可变序列的切片操作；数据类型本身的高早期:ist, set)： 重新分配一块内存，创建一个新的对象，其中的元素是原对象中子对象的引用。
### 如果元对象中的元素不可变，无所谓；如果元素可变，浅拷贝会带来副作用
## 深拷贝(copy.deepcopy)： 重新分配一块内存，创建一个新对象，并将原对象中的元素，以递归的方式，通过创建新的子对象拷贝到新对象中。因此：新对象和原对象没有任何关联

# 3. is: 比较引用； ==： 比较值
```

# 13. 值传递，引用传递 or 其他， Python中的参数传递
```
# 1. cpp中的值传递和引用传递
## 值传递：拷贝参数的值，传递给函数中的新变量，原变量和新变量间相互独立，互不影响
## 引用传递：把参数的引用传递给新的变量，原变量和新变量指向同一块内存地址

# 2. Python变量及赋值：
## 变量的赋值，只是标识让变量指向了某个对象，并不会拷贝对象给变量；对一个对象，可以被多个变量所指
## 可变对象的改变(列表，字典，集合等): 会影响所有指向该对象的变量
## 不可变对象(字符串，整形，元组): 所有指向该对象的变量的值总值一样的，也不会改变。但通过某些操作(+=)更新不可变对象的值时，会返回一个新的对象
## 变量可以删除，但对象无法被删除

# 3. Python函数的参数传递：
## 赋值传递&对象引用传递；Python中所有的数据类型都是对象，所以参数传递时，只是让新变量与原变量指向相同的对象，不存在值传递或引用传递
## 并不指向一个具体的内存地址，而是指向一个具体的对象；对象可变，当其改变时，所有指向这个对象的变量都会改变
## 不可变：： 简单赋值只能改变其中一个变量的值，其余变量不受影响。

```

# 14. 装饰器
```
# 1. 函数 -> 装饰器
## 简单装饰器； 带参数装饰器；类装饰器；装饰器的嵌套
# 2. 装饰器用法示例：
## 身份认证
## 日志记录
## 输入合理性校验
## 缓存
# 3. 装饰器： 通过装饰器函数，来修改函数的一些原功能，使得原函数不需要修改
```

# 15. metaclass
```
# 1. metaclass的超越变形特性：
## yamlObject： 它的任意子类支持㤡和反序列化
## 超动态配置编程

# 2. metaclass 的超越变形特性如何使用：
## 全局注册器

# 3. Python底层语言设计如何实现metaclass：
## meatclass 能够拦截Python类的定义： Python类型模型
## 3.1 所有Python的用户定义类，都是type这个类的实例
## 3.2 用户自定义类，只不过时type类的__call__运算符重载
## 3.3 metaclass 是 type的子类，通过替换type 的__call__运算重载符，超越变形正常的类

# 4. 风险： metaclass 会扭曲变形正常的Python类型模型
```

# 16. 深入理解迭代器和生成器
```
# 1. 容器，可迭代对象，迭代器
## 容器是可迭代对象，可迭代对象调用iter函数，得到一个迭代器
# 2. 生成器：
## 生成器是一种特殊的迭代器
## 降低内存占用， 优化程序结构， 提高程序速度
# 3. Python2中生成器是协程的一种重要实现方式； Python3.5 引入async await后生成器实现协程的方式落后
```

# 17. Python协程
```
# 1. 背景： C10K瓶颈： 同时连接到服务器的客户达到了一万个，进程上下文切换占用了大量资源，线程也顶不住压力；
## nginx 事件循环： 启动一个统一的调度器，让调度器决定一个时刻去运行哪个任务： 产生了多线程中的启动线程，管理线程，同步锁等各种开销
## 回调地狱：
## 协程： 继承了事件循环的优越性，提供async/await语法糖，解决了执行性和可读性共存的难题

# 2. 协程运行时

# 3. 完整的协程爬虫
```

# 18. Python并发编程Future
```
# 1. 区分并行和并发
# 2. 并发编程Futures
## 2.1 单线程和多线程的性能比较
## 2.2 什么是Futures： executor.submit() -> as_completed(); done(), result()

## 2.3 为什么多线程每次只能有一个线程执行
```

# 19. python并发编程Asyncio
```
# 1. 什么是Asyncio
## 1.1 Sync  Async
## 1.2 Asyncio 工作原理
## 1.3 Asyncio 用法：

# 2. Asyncio 缺陷

# 3. 多线程 & Asyncio：
# io 密集型，io操作慢，需要很多任务/线程协同实现，使用Asnycio
# io 密集型，io操作快，只需要有限数量任务/线程，使用多线程
# cpu 密集型， 多进程
```

# 20. Python GIL(全局解释器锁)
```
# 1. gil 效果： cpu密集型任务由python执行时，多线程慢于单线程
# 2. 为什么有gil： 
# 3. gil 如何工作：
# 4. gil 的线程工作：
# 5. 如何绕过gil：
## 绕过CPython， 使用Jpython等其他实现
## 将关键性能代码放到其他语言中实现(cpp)
```

# 21. Python 垃圾回收
```
# 内存泄露： 不是内存在物理上消失，仅意味着代码在分配了某段内存后，因为设计错误，失去了对这段内存的控制，造成内存的浪费
# 1. 计数引用：
# 2. 循环引用：
## 自动回收：标记清除，分代整理； 主要针对循环引用的垃圾收集
# 3. 调试内存泄露：
## objgraph: 很好用的可视化引用关系包：生成引用关系图
```

# 22. GIL 与多线程的关系

# #################################################################
# 规范
# 23. 代码风格
```
# 1. 编程风格： PEP8 & Google Style ： http://google.github.io/styleguide/pyguide.html
## exp: 命名必须有意义
## exp2: import 对象， 只能是package或module， from...import... 被禁用
## exp3: 盲目使用list comprehension
## exp4: is 比较对象的堆存地址， 和None比较； ==； 隐式布尔转换
## exp5: 遍历方式限制： dict对象 禁用keys()方法：会在遍历前生成一个临时的列表，消耗大量内存且运行缓慢
# 2. 整合进开发流程的自动化工具
## 开发 -> 代码评审 & 可读性评审 -> 编程规范自动linter -> 代码提交

# 3. 代码分解：

```

# 24. assert
```
# 1. 什么是assert：
## debug 工具： 用于测试一个条件是否满足

# 2. assert 用法：
## 防御编程：输入合法性校验

# 3. assert 不适用于run-time error 的检查
```

# 25. 巧用上下文管理器和with语句精简代码
```
# 1. 资源管理操作：必须保证资源在使用后释放，否则会资源泄露：系统处理缓慢，系统崩溃

# 2. 引入上下文管理器： 自动分配并释放资源， 典型应用： with语句， 替换try...finally...
## 文件读写 & threading.lock

# 3. 上下文管理器实现：
## 3.1 基于类的上下文管理器(灵活)：包括 "__enter__()"返回需要被管理的资源 & "__exit__()"释放，清理资源
## 3.2 基于生成器的上下文管理器：使用装饰器 contextlib.contextmanager, 定义所需的基于生成器的上下文管理器 ，用以支持with语句

```

# 26. 单元测试
```
# 1. unitest.TestCase

# 2. 单元测试技巧(通过虚假的实现，替换掉被测试函数的一些依赖项，将更多精力放在需要被测试的功能)：
## mock： 通过虚假对象，代替被测试函数或模块需要改的对象
## side_effect： 
## patch

# 3. 高质量单元测试：
## Test coverage：衡量代码中被cover的百分比
## 模块化： 

```

# 27. pdb & cProfile: 调式和性能分析
```
# 1. pdb的必要性：单一语言的IDE， 对混合代码不支持UI形式的，要求命令行形式的代码调试

# 2. 如何使用： import pdb && pdb.set_trace()
## 命令行：p 打印变量值； n 代码执行到下一行； l 列举当前代码行上下的11行源码； s 步进step into; r 继续执行直到当前函数完成返回step out; b 设置断点； c 一直执行，直到遇到下一个端点

# 3. cProfile 性能分析： import cProfile && cProfile.run()
## 准确计算每个模块消耗的时间
```

# 28. 选择合适的异常处理方式
```

```

# #####################################################################
# 实战
# 29. RESTful & Socket 搭建交易执行层核心
```
# 1. REST 简介： 表征层状态转移：本意是一种资源操作方法： 通过URL定位资源，用GET POST PUT DELETE 描述操作
## 无状态： 每个rest 请求都是独立的，不需要服务器在绘画中缓存中间状态完成： 一个http请求完成一次完整操作

# 2. 交易所API: 
## Gemini： 买， 卖， 市价单， 限价单

# 3. API 下单：
## 注册Gemini Sandbox账号 & 配置API Key
## 3.1 下单逻辑： 构造请求订单 & 加密请求 & post给gemini交易所
## 3.2 post 接收三个参数： url， data， headers
## 构造 request_headers
## 字典： Content-Type: text/plain & Contest-Length: 0 & keep-alive
## pay-load: 存储下单操作需要的所有信息； nonce：单调递增,消息去重
## 对pay-load 进行base64 和 sha384 非对称加密
```

# 30. RESTful & Socket 行数数据对接和抓取
```
# 1. 行情数据： 
## 买卖双方提供商品数和意愿价格给交易所，交易所按公平原则撮合
## 限价订单：盘口数据，按价格高低排序
## 两种行情数据： 委托账本(Order book) & 活动行情(Tick data)

# 2. WebSocket： 
## 行情数据讲求时效性； 行情从交易所产生到传播给程序间的延迟越低越好
## 在单个tcp/tls连接上，进行全双工，双向通信的协议，可以让客户端和服务器间的数据交换更加高效简单
## 在WebSocket API 中浏览器和服务器只需要完成一次握手，两者间就可以直接创建持久性连接，并进行双向数据传输
## 更加实时高效的数据交换方式， 但请求和回复异步，程序的状态控制逻辑更为复杂

# 3. 行情数据抓取： 
## 交易所提供两种websocket接口： public private
## public： 公开接口， 提供orderbook服务，每个人都看得到当前的挂单价和深度
## private： 挂单操作：订单被完全执行，被部分执行等其他变动
```

# 31. Pandas & Numpy: 策略与回测系统
```
# 1. ohlcv 数据：
## k线， 抓取tick底层原始数据，聚合出1分钟k线，1小时k线，周k线
## 数据下载完成后，pandas读取数据； read_file 读取csv文件； assert_msg: 传入参数校验

# 2. 回测框架：
## 2.1 向量化回测： Pandas+Numpy搭建计算核心 & MySQL或MongoDB作为源，通过Pandas+Numpy对OHLC数组进行向量运算，可以在较长的历史数据上进行回测
## 2.2 事件驱动回测(zipline & PyAlgoTrade): 针对每个tick的变动或orderbook的变动生成事件，然后将一个个事件交给策略进行执行，拓展性强，允许更灵活的策略但回测速度慢
## 2.3 流程：读取OHLC数据 & 对OHLC进行指标运算 & 策略根据指标向量决定买卖 & 模拟交易所执行交易 & 统计结果
## 2.4 面向对象编程抽取三个类：
## 交易所类(ExchageAPI)： 维护账户的资金和仓位，进行模拟的买卖
## 策略类(Stragegy)：根据市场信息生成指标，根据指标决定买卖
## 回测类框架(Backtest)： 包含一个策略类和一个交易所类，迭代的对每个数据点调用策略执行


# 3. 交易策略：
## 3.1 exp1: 移动均值交叉策略

# 4. 模拟交易：
## 模拟基础需要当前市场的价格：用OHLC中的close作为需求的价格
## 简化设计： 假设买卖操作都利用当前账户的所有资金，仓位，且市场容量足够大，这样下单请求能够马上完全执行
## 手续费：
## 真：sma交叉会由于手续费摩擦和滑点让高频策略赔钱
## 假：模拟交易方式粗糙。真实情况：买卖请求马上执行；市场中进行交易的同时不会影响市场价格；
```

# 32. Kafka & ZMQ: 自动化交易流水线
```
# 1. 中间件：底层工具和应用层工具进行连接
# 2. 消息队列： 临时存放消息的容器：生产者推送消息到队列，消费者监听消息队列
# 3. ZMQ: 轻量级消息队列实现
## 三种模式：request-reply & publish-subscribe & parallel pipeline
# 4. Kafka
## 点对点 & 发布订阅

# 5. 基于消息队列的Orderbook数据流：
## 获取orderbook的两种用途： 策略段获取实时数据，用来做决策； 备份在文件或数据库中，方便让策略和回测系统将来使用
## 分布式监听交易所数据，经由消息队列处理传给量化交易系统
```

# 33. MySQL: 日志和数据存储系统
```
# 1. 快速理解 MySQL
## mysqlclient
## peewee

# 2. 量化数据分析
# 3. 分布式日志系统
# 4. 日志分析
```

# 34. Django：搭建监控平台
```
# 1. Django 简介安装

# 2. MVC架构
## 设计模型model
## 设计视图views
## 设计模板templates
## 设计链接urls
## 测试

# 3. 监控系统开源插件： 
## Grahpite 存储时间序列数据，并通过django web应用沉痼在图形中显式的插件
## Vimeo 基于Graphite的仪表板，附加平滑设计
## Scout 监控Django 和 Flask应用程序的性能，提供自动监测视图，sql查询，模板等

```

# 35. Python中的数据结构和算法全景
```
# 数组 堆 栈 队列 链表
# 无向图 有向图 树 DAG图 字典树 哈希表

# 排序
# 二分
# dfs & bfs
# greedy & dp

```

# other
# file:///C:/Users/lin/Desktop/pdf/32-Python%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E8%B7%B5/OEBPS/Text/45.html
# swig python 的c & cpp 接口
```
# SWIG: 能够连接c/cpp与多种高级编程语言的软件开发工具。 swig支持多种不同类型的目标语言 

# 使用Python 实现PCA算法

# 准备SWIG
## 网址：http://swig.org/download.html
## 生成 _pca.so库供Python使用
## swig -c++ -python pca.i # 解释接口定义生成包swig装饰器代码
## g++ -fPIC -c pca.h pca.cpp utils.h utils.cpp pca_wrap.cxx -I/usr/include/python3.7 # 编译
## g++ -shared pca.o pca_wrap.o utils.o -o _pca.so -O2 -Wall -std=c+11 -pthread -shared -fPIC -LARMADILLO # 链接
## 通过python脚本导入创建好的so动态库


# 通过SWIG封装基于C++编写的Python模块


# SWIG C++ 常用工具
# 1. 全局变量
# 2. 常量
# 3. Enumeration
# 4. 指针和引用
# 5. 字符串
# 6. 向量
# 7. 映射
```
# 技术研发注意事项
```

```


